#!/usr/bin/env bash

set -euo pipefail

# TGI dev box CLI Tool

# Configuration
CONFIG_FILE="./config.ini"
KEY_PATH="$HOME/.ssh/my_tgi_key.pem"
TAG_NAME="david-holtz-quick-nixos"
HF_TOKEN="YOUR_HF_TOKEN"
MODEL_NAME="meta-llama/Llama-3.1-8B-Instruct"
INSTANCE_TYPE="g6.48xlarge"
VOLUME_SIZE=512
IMAGE_ID="ami-0b3d51a362efa9e02"
REGION="us-east-1"
SUBNET_ID="YOUR_SUBNET_ID"
SECURITY_GROUP_ID="YOUR_SECURITY_GROUP_ID"

# get key name from KEY_PATH
KEY_NAME=$(basename "$KEY_PATH" .pem)

# Load configuration
load_config() {
    if [[ -f "$CONFIG_FILE" ]]; then
        source "$CONFIG_FILE"
    else
        echo "‚ùå Configuration file not found. Creating a new one..."
        create_config
        source "$CONFIG_FILE"
    fi

    KEY_NAME=$(basename "$KEY_PATH" .pem)
}

# Create example configuration file
create_config() {
    cat <<EOF >"$CONFIG_FILE"
KEY_PATH="$HOME/.ssh/my_tgi_key.pem"
TAG_NAME="YOUR_TAG_NAME"
HF_TOKEN=""
MODEL_NAME="meta-llama/Llama-3.1-8B-Instruct"
INSTANCE_TYPE="g6.48xlarge"
VOLUME_SIZE=512
IMAGE_ID="ami-0b3d51a362efa9e02"
REGION="us-east-1"
SUBNET_ID="YOUR_SUBNET_ID"
SECURITY_GROUP="YOUR_SECURITY_GROUP_ID"
EOF
    echo "‚úÖ Configuration file created at $CONFIG_FILE"
}


# Check that tag name is not default value
check_tag_name() {
    if [[ "$TAG_NAME" == "YOUR_TAG_NAME" ]]; then
        echo "‚ùå TAG_NAME is not set. Please set it in the configuration file and try again."
        exit 1
    fi
}


# Check dependencies
check_dependencies() {
    local deps=("aws" "ssh" "scp" "sed" "grep")
    for dep in "${deps[@]}"; do
        if ! command -v "$dep" &>/dev/null; then
            echo "‚ùå $dep is not installed. Please install it and try again."
            exit 1
        fi
    done
}

# Check AWS CLI configuration
check_aws_config() {
    if ! aws configure list &>/dev/null; then
        echo "‚ùå AWS CLI is not configured. Please run 'aws configure' to set it up."
        exit 1
    fi
}

# Check AWS SSO login
check_aws_sso() {
    if ! aws sts get-caller-identity &>/dev/null; then
        echo "‚ùå AWS SSO login required. Please run 'aws sso login' and try again."
        exit 1
    fi
}

# Generate NixOS configuration
generate_nixos_config() {
    cat <<EOF >/tmp/insta.nix
{ modulesPath, pkgs, lib, ... }: {
  imports = [
    "\${modulesPath}/virtualisation/amazon-image.nix"
    (builtins.fetchTarball "https://github.com/msteen/nixos-vscode-server/tarball/master")
#    ./cachix.nix # uncomment after adding cachix
  ];
  system.stateVersion = "24.05";
  services.vscode-server.enable = true;

  # Enable CUDA
  nixpkgs.config.allowUnfree = true;
  nixpkgs.config.cudaSupport = true;

  environment.systemPackages = with pkgs; [
    git
    gh
    zsh
    oh-my-zsh
    byobu
    tmux
    cachix
    cudaPackages.cudatoolkit
    nodejs
    vscode
    pre-commit
    ruff
  ];

  # Enable NVIDIA graphics
  hardware.nvidia = {
    modesetting.enable = true;
    open = false;
  };
  hardware.graphics = {
    enable = true;
    enable32Bit = true;
  };
  services.xserver.videoDrivers = [ "nvidia" ];

  # Set up Zsh as the default shell system-wide
  users.defaultUserShell = pkgs.zsh;

  # Configure Zsh and Oh My Zsh
  programs.zsh = {
    enable = true;
    ohMyZsh = {
      enable = true;
      theme = "robbyrussell";
      plugins = [ "git" "docker" "npm" ];
    };
    shellAliases = {
      update = "sudo nixos-rebuild switch";
      example = "echo 'yo'";
    };
  };

  # Enable nix-command and flakes features
  nix.settings.experimental-features = [ "nix-command" "flakes" ];
}
EOF
    echo "‚úÖ NixOS configuration generated at /tmp/insta.nix"
}

# Get instance private IP
get_private_ip() {
    local instance_id
    instance_id=$(aws ec2 describe-instances \
        --region "$REGION" \
        --filters "Name=tag:Name,Values=$TAG_NAME" "Name=instance-state-name,Values=running" \
        --query 'Reservations[0].Instances[0].InstanceId' \
        --output text)

    if [[ "$instance_id" == "None" ]]; then
        echo "‚ùå Instance not found. Exiting"
        exit 1
    fi

    aws ec2 describe-instances \
        --region "$REGION" \
        --instance-ids "$instance_id" \
        --query 'Reservations[0].Instances[0].PrivateIpAddress' \
        --output text
}

# SSH command wrapper
ssh_command() {
    local private_ip=$1
    shift
    ssh -o "StrictHostKeyChecking no" -i "$KEY_PATH" -t "root@$private_ip" "$@"
}

# SCP command wrapper
scp_command() {
    local private_ip=$1
    local src=$2
    local dest=$3
    scp -o "StrictHostKeyChecking no" -i "$KEY_PATH" "$src" "root@$private_ip:$dest"
}

# Create and setup a new devbox
up() {
    echo "üëç Creating and setting up a new devbox..."
    local start_time
    start_time=$(date +%s)

    generate_nixos_config

    if [[ ! -f "$KEY_PATH" ]]; then
        echo "‚ùå Key does not exist. Please create the key and try again"
        exit 1
    fi

    local instance_id
    instance_id=$(aws ec2 run-instances \
        --region "$REGION" \
        --instance-type "$INSTANCE_TYPE" \
        --image-id "$IMAGE_ID" \
        --key-name "$KEY_NAME" \
        --subnet-id "$SUBNET_ID" \
        --security-group-ids "$SECURITY_GROUP_ID" \
        --block-device-mappings "[{\"DeviceName\":\"/dev/xvda\",\"Ebs\":{\"VolumeSize\":$VOLUME_SIZE}}]" \
        --count 1 \
        --tag-specifications "ResourceType=instance,Tags=[{Key=Name,Value=$TAG_NAME}]" \
        --query 'Instances[0].InstanceId' \
        --output text)

    echo "‚úÖ Instance ID: $instance_id"

    aws ec2 wait instance-running --region "$REGION" --instance-ids "$instance_id"
    echo "‚úÖ Instance is running"

    local private_ip
    private_ip=$(get_private_ip)
    echo "‚úÖ Private IP: $private_ip"

    until ssh_command "$private_ip" "uptime"; do
        sleep 5
    done
    echo "‚úÖ Machine is accessible"

    scp_command "$private_ip" "/tmp/insta.nix" "/etc/nixos/configuration.nix"
    echo "‚úÖ Configuration file copied"

    ssh_command "$private_ip" "nix-channel --add https://nixos.org/channels/nixos-unstable-small nixos && nix-channel --update"
    echo "‚úÖ Nix channel set to unstable"

    ssh_command "$private_ip" "nixos-rebuild switch"
    echo "‚úÖ NixOS rebuild switch command run"

    ssh_command "$private_ip" "reboot"
    echo "‚úÖ Machine rebooting"

    until ssh_command "$private_ip" "uptime"; do
        sleep 5
    done
    echo "‚úÖ Machine is back up"

    ssh_command "$private_ip" "cachix use text-generation-inference"
    echo "‚úÖ Cachix use text-generation-inference"

    ssh_command "$private_ip" "sed -i '5s/^#//' /etc/nixos/configuration.nix"
    echo "‚úÖ Uncommented the 5th line of the configuration.nix"

    ssh_command "$private_ip" "nixos-rebuild switch"
    echo "‚úÖ NixOS rebuild switch command run"

    ssh_command "$private_ip" "git clone https://github.com/huggingface/text-generation-inference.git"
    echo "‚úÖ Cloned the repo"

    ssh_command "$private_ip" "cd text-generation-inference && nix develop .#pure --command ls"

    local end_time
    end_time=$(date +%s)
    local duration=$((end_time - start_time))
    echo "‚úÖ Setup time: $duration seconds."
}

# Setup the development environment
setup() {
    echo "üëç Setting up the development environment..."
    local start_time
    start_time=$(date +%s)

    local private_ip
    private_ip=$(get_private_ip)
    echo "‚úÖ Private IP: $private_ip"

    ssh_command "$private_ip" "export HF_TOKEN=$HF_TOKEN && cd text-generation-inference && nix develop .#impure --command bash -c 'cd server && make gen-server'"
    echo "‚úÖ Protobufs generated"

    ssh_command "$private_ip" "systemctl --user enable auto-fix-vscode-server.service"
    echo "‚úÖ Enabled auto-fix-vscode-server.service"

    ssh_command "$private_ip" "systemctl --user start auto-fix-vscode-server.service"
    echo "‚úÖ Started auto-fix-vscode-server.service"

    ssh_command "$private_ip" "ln -sfT /run/current-system/etc/systemd/user/auto-fix-vscode-server.service ~/.config/systemd/user/auto-fix-vscode-server.service"
    echo "‚úÖ Linked auto-fix-vscode-server.service"

    ssh_command "$private_ip" "export HF_TOKEN=$HF_TOKEN && cd text-generation-inference && nix develop .#impure --command text-generation-server download-weights $MODEL_NAME"
    echo "‚úÖ Weights downloaded"

    local end_time
    end_time=$(date +%s)
    local duration=$((end_time - start_time))
    echo "‚úÖ Script duration: $duration seconds"
}

# Add the devbox to local SSH config
add_to_local() {
    echo "üëç Adding devbox to local SSH config..."
    local start_time
    start_time=$(date +%s)

    local private_ip
    private_ip=$(get_private_ip)
    echo "‚úÖ Private IP: $private_ip"

    if ! grep -q "$TAG_NAME" "$HOME/.ssh/config"; then
        {
            echo ""
            echo "Host $TAG_NAME"
            echo "  HostName $private_ip"
            echo "  User root"
            echo "  IdentityFile $KEY_PATH"
        } >>"$HOME/.ssh/config"
        echo "‚úÖ Added to ~/.ssh/config"
    else
        echo "‚úÖ Already in ~/.ssh/config"
        local current_private_ip
        current_private_ip=$(grep -A 3 "$TAG_NAME" "$HOME/.ssh/config" | grep HostName | awk '{print $2}')
        if [[ "$current_private_ip" != "$private_ip" ]]; then
            echo "‚ùå Private IP is different. Updating ~/.ssh/config"
            sed -i '' "s/$current_private_ip/$private_ip/g" "$HOME/.ssh/config"
        else
            echo "‚úÖ Private IP is the same"
        fi
    fi

    local end_time
    end_time=$(date +%s)
    local duration=$((end_time - start_time))
    echo "‚úÖ Script duration: $duration seconds"
}

# Open a byobu session with three panes
open_session() {
    echo "üëç Opening a three-pane byobu session..."
    local start_time
    start_time=$(date +%s)

    local private_ip
    private_ip=$(get_private_ip)
    echo "‚úÖ Private IP: $private_ip"

    ssh_command "$private_ip" "cd text-generation-inference && nix develop .#impure --command ls && byobu new-session -d -s mysession && byobu split-window -v && byobu split-window -v && byobu select-layout even-vertical && byobu send-keys -t 0 'nix develop .#impure' C-m && byobu send-keys -t 1 'nix develop .#impure' C-m && byobu send-keys -t 2 'nix develop .#impure' C-m && byobu attach-session -t mysession"

    local end_time
    end_time=$(date +%s)
    local duration=$((end_time - start_time))
    echo "‚úÖ Script duration: $duration seconds"
}

# Shutdown the devbox
down() {
    echo "üëç Shutting down the devbox..."
    local start_time
    start_time=$(date +%s)

    local instance_id
    instance_id=$(aws ec2 describe-instances \
        --region "$REGION" \
        --filters "Name=tag:Name,Values=$TAG_NAME" "Name=instance-state-name,Values=running" \
        --query 'Reservations[0].Instances[0].InstanceId' \
        --output text)

    echo "‚úÖ Instance ID: $instance_id"

    if [[ "$instance_id" == "None" ]]; then
        echo "‚ùå Instance was not created. Exiting"
        exit 1
    fi

    aws ec2 terminate-instances \
        --region "$REGION" \
        --instance-ids "$instance_id" \
        --output text

    local end_time
    end_time=$(date +%s)
    local duration=$((end_time - start_time))
    echo "‚úÖ Script duration: $duration seconds"
}

# Display usage information
usage() {
    cat <<EOF
Usage: $0 <command> [options]
Commands:
  status          Get the status of the devbox
  up              Create and setup a new devbox
  setup           Setup the development environment
  add-to-local    Add the devbox to local SSH config
  open            Open a byobu session with three panes
  ssh             SSH into the devbox
  down            Shutdown the devbox
  help            Display this help message
EOF
}

# Main script logic
main() {
    load_config
    check_tag_name
    check_dependencies
    check_aws_config
    check_aws_sso

    case "$1" in
    status)
        get_private_ip
        ;;
    up)
        up
        ;;
    setup)
        setup
        ;;
    add-to-local)
        add_to_local
        ;;
    open)
        open_session
        ;;
    ssh)
        ssh_command "$(get_private_ip)"
        ;;
    down)
        down
        ;;
    help)
        usage
        ;;
    *)
        echo "Error: Unknown command '$1'"
        usage
        exit 1
        ;;
    esac
}

main "$@"
